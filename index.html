<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tinygrad has WebGPU</title>

    <style>
        body {
            font-family: 'Arial', sans-serif;
            text-align: center;
            padding: 30px;
        }

        a {
            text-decoration: none;
            color: #4A90E2;
        }

        h1 {
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 20px;
        }

        #mybox {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 50%;
            margin: 0 auto;
        }

        #promptText, #stepRange, #btnRunNet, #guidanceRange {
            font-size: 18px;
            width: 100%;
        }

        #result {
            font-size: 48px;
        }

        #time {
            font-size: 16px;
            color: grey;
        }

        canvas {
            margin-top: 20px;
            border: 1px solid #000; 
        }

        label {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        
        #sliderValue {
            margin-right: 10px;/
        }
    </style>

    <script type="module">
        import ClipTokenizer from 'https://softwired.nyc3.cdn.digitaloceanspaces.com/sd/clip_tokenizer.js';
        window.clipTokenizer = new ClipTokenizer();
    </script>
    <script src="./net.js"></script>
</head>

<body>
<h1 id="wgpuError" style="display: none; color: red;">WebGPU is not supported in this browser</h1>
<h1 id="sdTitle">StableDiffusion by <a href="https://github.com/tinygrad/tinygrad" target="_blank">TinyGrad</a> WebGPU</h1>
<div id="mybox">
    <input id="promptText" type="text" placeholder="Enter your prompt here" value="a horse sized cat eating a bagel">
    
    <label>
        Steps: <span id="stepValue">8</span>
        <input id="stepRange" type="range" min="5" max="20" value="8" step="1">
    </label>

    <label>
        Guidance: <span id="guidanceValue">7.5</span>
        <input id="guidanceRange" type="range" min="3" max="15" value="7.5" step="0.1">
    </label>
    
    <input id="btnRunNet" type="button" value="Run" disabled>

    <div id="divModelDl" style="display: flex; align-items: center; width: 100%; gap: 10px;">
        <span id="modelDlTitle">Downloading model</span>
        <progress id="modelDlProgressBar" value="0" max="100" style="flex-grow: 1;"></progress>
        <span id="modelDlProgressValue"></span>
    </div>

    <div id="divStepProgress" style="display: none; align-items: center; width: 100%; gap: 10px;">
        <progress id="progressBar" value="0" max="100" style="flex-grow: 1;"></progress>
        <span id="progressFraction"></span>
    </div>
</div>
<canvas id="canvas" width="512" height="512"></canvas>

<script>
    window.addEventListener('load', function() {
        if (!navigator.gpu) {
            document.getElementById("wgpuError").style.display = "";
            document.getElementById("sdTitle").style.display = "none";
            
            return;
        }

        const ctx = document.getElementById("canvas").getContext("2d", { willReadFrequently: true });
        let labels, nets, safetensorParts;

        const getDevice = async () => {
            const adapter = await navigator.gpu.requestAdapter();
            const requiredLimits = {};
            const maxBufferSizeInSDModel = 1073741824;
            requiredLimits.maxStorageBufferBindingSize = maxBufferSizeInSDModel;
            requiredLimits.maxBufferSize = maxBufferSizeInSDModel;
            
            return await adapter.requestDevice({
            requiredLimits,
            }	);
        };

        const timer = async (func, label = "") => {
            const start = performance.now();
            const out = await func();
            const delta = (performance.now() - start).toFixed(1)
            console.log(`${delta} ms ${label}`);
            return out;
        }

        const loadNet = async () => {
            const modelDlTitle = document.getElementById("modelDlTitle");

            const progress = (loaded, total) => {
                document.getElementById("modelDlProgressBar").value = (loaded/total) * 100
                document.getElementById("modelDlProgressValue").innerHTML = Math.trunc((loaded/total) * 100) + "%"
            }

            safetensorParts = await getSafetensorParts(progress);

            modelDlTitle.innerHTML = "Compiling model"

            let models = ["textModel", "diffusor", "decoder"];
            const device = await getDevice();

            nets = await timer(() => Promise.all([
                textModel().setup(device, safetensorParts),
                diffusor().setup(device, safetensorParts),
                decoder().setup(device, safetensorParts)
            ]).then((loadedModels) => loadedModels.reduce((acc, model, index) => { acc[models[index]] = model; return acc; }, {})), "(compilation)")
            console.log(nets)

            modelDlTitle.innerHTML = "Model ready"
            setTimeout(() => {
                document.getElementById("modelDlProgressBar").style.display = "none";
                document.getElementById("modelDlProgressValue").style.display = "none";
                document.getElementById("divStepProgress").style.display = "flex";
            }, 1000);
            document.getElementById("btnRunNet").disabled = false;
        }

        function runStableDiffusion(prompt, steps, guidance) {
            return new Promise(async (resolve, reject) => {
                let context = await timer(() => nets["textModel"](clipTokenizer.encodeForCLIP(prompt)));
                let unconditional_context = await timer(() => nets["textModel"](clipTokenizer.encodeForCLIP("")));

                let timesteps = [];

                for (let i = 1; i < 1000; i += (1000/steps)) {
                    timesteps.push(i);
                }

                console.log("Timesteps: " + timesteps);

                let alphasCumprod = getWeight(safetensorParts, "alphas_cumprod");
                let alphas = [];

                for (t of timesteps) {
                    alphas.push(alphasCumprod[Math.floor(t)]);
                }

                alphas_prev = [1.0];

                for (let i = 0; i < alphas.length-1; i++) {
                    alphas_prev.push(alphas[i]);
                }

                let inpSize = 4*64*64;
                latent = new Float32Array(inpSize);

                for (let i = 0; i < inpSize; i++) {
                    latent[i] = Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());
                }
                
                for (let i = timesteps.length - 1; i >= 0; i--) {
                    let timestep = new Float32Array([timesteps[i]]);
                    let x_prev = await timer(() => nets["diffusor"](unconditional_context, context, latent, timestep, new Float32Array([alphas[i]]), new Float32Array([alphas_prev[i]]), new Float32Array([guidance])));
                    latent = x_prev;
                    document.getElementById("progressBar").value = ((steps - i) / steps) * 100
                    document.getElementById("progressFraction").innerHTML = (steps - i) + "/" + steps
                }
                
                resolve(await timer(() => nets["decoder"](latent)));
            });
        }

        document.getElementById("btnRunNet").addEventListener("click", function(e) {
            e.target.disabled = true;

            runStableDiffusion(document.getElementById("promptText").value, document.getElementById("stepRange").value, document.getElementById("guidanceRange").value).then((image) => {
                let pixels = []
                let pixelCounter = 0

                for (let j = 0; j < 512; j++) {
                    for (let k = 0; k < 512; k++) {
                        pixels.push(image[pixelCounter])
                        pixels.push(image[pixelCounter+1])
                        pixels.push(image[pixelCounter+2])
                        pixels.push(255)
                        pixelCounter += 3
                    }
                }
                
                ctx.putImageData(new ImageData(new Uint8ClampedArray(pixels), 512, 512), 0, 0);
                console.log(image);
                console.log("Success");
                e.target.disabled = false;
            });
        }, false);

        const stepSlider = document.getElementById('stepRange');
        const stepValue = document.getElementById('stepValue');

        stepSlider.addEventListener('input', function() {
            stepValue.textContent = stepSlider.value;
        });

        const guidanceSlider = document.getElementById('guidanceRange');
        const guidanceValue = document.getElementById('guidanceValue');

        guidanceSlider.addEventListener('input', function() {
            guidanceValue.textContent = guidanceSlider.value;
        });

        loadNet();
    });
</script>
</body>
</html>
